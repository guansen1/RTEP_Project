#include "display.hpp"
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/i2c-dev.h>
#include <cstring>
#include <iostream>

// 定义 I2C 设备文件和 OLED 地址
#define I2C_DEVICE "/dev/i2c-1"
#define SSD1306_ADDR 0x3C

// 5x7 字体数据（ASCII 32 至 127，公共领域字体）
const uint8_t SSD1306Display::font5x7[96][5] = {
    {0x00,0x00,0x00,0x00,0x00}, // 32 空格
    {0x00,0x00,0x5F,0x00,0x00}, // 33 !
    {0x00,0x07,0x00,0x07,0x00}, // 34 "
    {0x14,0x7F,0x14,0x7F,0x14}, // 35 #
    {0x24,0x2A,0x7F,0x2A,0x12}, // 36 $
    {0x23,0x13,0x08,0x64,0x62}, // 37 %
    {0x36,0x49,0x55,0x22,0x50}, // 38 &
    {0x00,0x05,0x03,0x00,0x00}, // 39 '
    {0x00,0x1C,0x22,0x41,0x00}, // 40 (
    {0x00,0x41,0x22,0x1C,0x00}, // 41 )
    {0x14,0x08,0x3E,0x08,0x14}, // 42 *
    {0x08,0x08,0x3E,0x08,0x08}, // 43 +
    {0x00,0x50,0x30,0x00,0x00}, // 44 ,
    {0x08,0x08,0x08,0x08,0x08}, // 45 -
    {0x00,0x60,0x60,0x00,0x00}, // 46 .
    {0x20,0x10,0x08,0x04,0x02}, // 47 /
    {0x3E,0x51,0x49,0x45,0x3E}, // 48 0
    {0x00,0x42,0x7F,0x40,0x00}, // 49 1
    {0x42,0x61,0x51,0x49,0x46}, // 50 2
    {0x21,0x41,0x45,0x4B,0x31}, // 51 3
    {0x18,0x14,0x12,0x7F,0x10}, // 52 4
    {0x27,0x45,0x45,0x45,0x39}, // 53 5
    {0x3C,0x4A,0x49,0x49,0x30}, // 54 6
    {0x01,0x71,0x09,0x05,0x03}, // 55 7
    {0x36,0x49,0x49,0x49,0x36}, // 56 8
    {0x06,0x49,0x49,0x29,0x1E}, // 57 9
    {0x00,0x36,0x36,0x00,0x00}, // 58 :
    {0x00,0x56,0x36,0x00,0x00}, // 59 ;
    {0x08,0x14,0x22,0x41,0x00}, // 60 <
    {0x14,0x14,0x14,0x14,0x14}, // 61 =
    {0x00,0x41,0x22,0x14,0x08}, // 62 >
    {0x02,0x01,0x51,0x09,0x06}, // 63 ?
    {0x32,0x49,0x79,0x41,0x3E}, // 64 @
    {0x7E,0x11,0x11,0x11,0x7E}, // 65 A
    {0x7F,0x49,0x49,0x49,0x36}, // 66 B
    {0x3E,0x41,0x41,0x41,0x22}, // 67 C
    {0x7F,0x41,0x41,0x22,0x1C}, // 68 D
    {0x7F,0x49,0x49,0x49,0x41}, // 69 E
    {0x7F,0x09,0x09,0x09,0x01}, // 70 F
    {0x3E,0x41,0x49,0x49,0x7A}, // 71 G
    {0x7F,0x08,0x08,0x08,0x7F}, // 72 H
    {0x00,0x41,0x7F,0x41,0x00}, // 73 I
    {0x20,0x40,0x41,0x3F,0x01}, // 74 J
    {0x7F,0x08,0x14,0x22,0x41}, // 75 K
    {0x7F,0x40,0x40,0x40,0x40}, // 76 L
    {0x7F,0x02,0x0C,0x02,0x7F}, // 77 M
    {0x7F,0x04,0x08,0x10,0x7F}, // 78 N
    {0x3E,0x41,0x41,0x41,0x3E}, // 79 O
    {0x7F,0x09,0x09,0x09,0x06}, // 80 P
    {0x3E,0x41,0x51,0x21,0x5E}, // 81 Q
    {0x7F,0x09,0x19,0x29,0x46}, // 82 R
    {0x46,0x49,0x49,0x49,0x31}, // 83 S
    {0x01,0x01,0x7F,0x01,0x01}, // 84 T
    {0x3F,0x40,0x40,0x40,0x3F}, // 85 U
    {0x1F,0x20,0x40,0x20,0x1F}, // 86 V
    {0x3F,0x40,0x38,0x40,0x3F}, // 87 W
    {0x63,0x14,0x08,0x14,0x63}, // 88 X
    {0x07,0x08,0x70,0x08,0x07}, // 89 Y
    {0x61,0x51,0x49,0x45,0x43}, // 90 Z
    {0x00,0x7F,0x41,0x41,0x00}, // 91 [
    {0x02,0x04,0x08,0x10,0x20}, // 92 '\'
    {0x00,0x41,0x41,0x7F,0x00}, // 93 ]
    {0x04,0x02,0x01,0x02,0x04}, // 94 ^
    {0x40,0x40,0x40,0x40,0x40}, // 95 _
    {0x00,0x01,0x02,0x04,0x00}, // 96 `
    {0x20,0x54,0x54,0x54,0x78}, // 97 a
    {0x7F,0x48,0x44,0x44,0x38}, // 98 b
    {0x38,0x44,0x44,0x44,0x20}, // 99 c
    {0x38,0x44,0x44,0x48,0x7F}, // 100 d
    {0x38,0x54,0x54,0x54,0x18}, // 101 e
    {0x08,0x7E,0x09,0x01,0x02}, // 102 f
    {0x0C,0x52,0x52,0x52,0x3E}, // 103 g
    {0x7F,0x08,0x04,0x04,0x78}, // 104 h
    {0x00,0x44,0x7D,0x40,0x00}, // 105 i
    {0x20,0x40,0x44,0x3D,0x00}, // 106 j
    {0x7F,0x10,0x28,0x44,0x00}, // 107 k
    {0x00,0x41,0x7F,0x40,0x00}, // 108 l
    {0x7C,0x04,0x18,0x04,0x78}, // 109 m
    {0x7C,0x08,0x04,0x04,0x78}, // 110 n
    {0x38,0x44,0x44,0x44,0x38}, // 111 o
    {0x7C,0x14,0x14,0x14,0x08}, // 112 p
    {0x08,0x14,0x14,0x18,0x7C}, // 113 q
    {0x7C,0x08,0x04,0x04,0x08}, // 114 r
    {0x48,0x54,0x54,0x54,0x20}, // 115 s
    {0x04,0x3F,0x44,0x40,0x20}, // 116 t
    {0x3C,0x40,0x40,0x20,0x7C}, // 117 u
    {0x1C,0x20,0x40,0x20,0x1C}, // 118 v
    {0x3C,0x40,0x30,0x40,0x3C}, // 119 w
    {0x44,0x28,0x10,0x28,0x44}, // 120 x
    {0x0C,0x50,0x50,0x50,0x3C}, // 121 y
    {0x44,0x64,0x54,0x4C,0x44}, // 122 z
    {0x00,0x08,0x36,0x41,0x00}, // 123 {
    {0x00,0x00,0x7F,0x00,0x00}, // 124 |
    {0x00,0x41,0x36,0x08,0x00}, // 125 }
    {0x10,0x08,0x08,0x10,0x08}, // 126 ~
    {0x00,0x00,0x00,0x00,0x00}  // 127 (DEL)
};

// 构造函数：初始化缓冲区，打开 I2C 设备，执行初始化序列
SSD1306Display::SSD1306Display() : i2c_fd(-1) {
    memset(buffer, 0, sizeof(buffer));
    i2c_fd = open(I2C_DEVICE, O_RDWR);
    if (i2c_fd < 0) {
        perror("打开 I2C 设备失败");
    }
    if (ioctl(i2c_fd, I2C_SLAVE, SSD1306_ADDR) < 0) {
        perror("获取 SSD1306 总线控制权失败");
    }
    if (!initialize()) {
        std::cerr << "SSD1306 初始化失败！" << std::endl;
    }
}

// 析构函数：关闭 I2C 设备
SSD1306Display::~SSD1306Display() {
    if (i2c_fd >= 0) {
        close(i2c_fd);
    }
}

// 发送一个命令字节（控制字节为 0x00）
bool SSD1306Display::writeCommand(uint8_t cmd) {
    uint8_t data[2];
    data[0] = 0x00; // 命令控制字节
    data[1] = cmd;
    if (write(i2c_fd, data, 2) != 2) {
        perror("写入命令失败");
        return false;
    }
    return true;
}

// 发送数据块（数据控制字节为 0x40）
bool SSD1306Display::writeData(const uint8_t *data, size_t length) {
    uint8_t *buf = new uint8_t[length + 1];
    buf[0] = 0x40; // 数据控制字节
    memcpy(buf + 1, data, length);
    if (write(i2c_fd, buf, length + 1) != (ssize_t)(length + 1)) {
        perror("写入数据失败");
        delete[] buf;
        return false;
    }
    delete[] buf;
    return true;
}

// 发送标准初始化命令序列
bool SSD1306Display::initialize() {
    std::lock_guard<std::mutex> lock(displayMutex);
    if (!writeCommand(0xAE)) return false; // 关闭显示
    if (!writeCommand(0xD5)) return false; // 设置时钟分频
    if (!writeCommand(0x80)) return false; // 设置建议比例
    if (!writeCommand(0xA8)) return false; // 设置多路复用率
    if (!writeCommand(0x3F)) return false; // 63 (0~63)
    if (!writeCommand(0xD3)) return false; // 设置显示偏移
    if (!writeCommand(0x00)) return false; // 无偏移
    if (!writeCommand(0x40)) return false; // 设置起始行地址
    if (!writeCommand(0x8D)) return false; // Charge Pump 设置
    if (!writeCommand(0x14)) return false; // 启用 Charge Pump
    if (!writeCommand(0x20)) return false; // 内存地址模式
    if (!writeCommand(0x00)) return false; // 水平地址模式
    if (!writeCommand(0xA1)) return false; // 设置段重映射
    if (!writeCommand(0xC8)) return false; // 设置 COM 输出扫描方向
    if (!writeCommand(0xDA)) return false; // 设置 COM 引脚配置
    if (!writeCommand(0x12)) return false;
    if (!writeCommand(0x81)) return false; // 设置对比度
    if (!writeCommand(0xCF)) return false;
    if (!writeCommand(0xD9)) return false; // 设置预充电周期
    if (!writeCommand(0xF1)) return false;
    if (!writeCommand(0xDB)) return false; // 设置 VCOMH 去除电平
    if (!writeCommand(0x40)) return false;
    if (!writeCommand(0xA4)) return false; // 恢复显示 RAM 内容
    if (!writeCommand(0xA6)) return false; // 正常显示
    if (!writeCommand(0xAF)) return false; // 开启显示
    return true;
}

// 将缓冲区写入屏幕之前，需要设置列地址和页地址
bool SSD1306Display::updateBuffer() {
    std::lock_guard<std::mutex> lock(displayMutex);
    if (!writeCommand(0x21)) return false; // 设置列地址命令
    if (!writeCommand(0x00)) return false; // 起始列 0
    if (!writeCommand(0x7F)) return false; // 结束列 127
    if (!writeCommand(0x22)) return false; // 设置页地址命令
    if (!writeCommand(0x00)) return false; // 起始页 0
    if (!writeCommand(0x07)) return false; // 结束页 7
    if (!writeData(buffer, sizeof(buffer))) return false;
    return true;
}

// 清空缓冲区并刷新显示
bool SSD1306Display::clear() {
    std::lock_guard<std::mutex> lock(displayMutex);
    memset(buffer, 0x00, sizeof(buffer));
    return updateBuffer();
}

// 根据传入文本，将字符绘制到对应页和列，然后刷新显示
// 每个字符占 6 列（5 列字形 + 1 列间隔）
bool SSD1306Display::updateText(const std::string &text, int page, int col) {
    std::lock_guard<std::mutex> lock(displayMutex);
    if (page < 0 || page >= PAGES || col < 0 || col >= WIDTH) return false;
    int pos = page * WIDTH + col;
    for (char c : text) {
        if (c < 32 || c > 127) continue; // 忽略不支持字符
        const uint8_t* glyph = font5x7[c - 32];
        for (int i = 0; i < 5; i++) {
            if (pos < (int)sizeof(buffer))
                buffer[pos++] = glyph[i];
        }
        // 加入一列空白
        if (pos < (int)sizeof(buffer))
            buffer[pos++] = 0x00;
        // 超出一行则停止
        if ((pos % WIDTH) >= WIDTH) break;
    }
    return updateBuffer();
}
